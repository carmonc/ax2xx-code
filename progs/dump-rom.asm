.equ	IEN, 0xA8

.equ	SFR_80, 0x80
.equ	SD_DATL, 0xD6
.equ	SD_DATH, 0xD7

.equ	SD_BYTES, 0xDE  ; SD byte count

.equ	SDDIR, 0xEB
.equ	SDSM, 0x90

.equ	SDCMD, 0xE6
.equ	SD_XMIT, 0xE7
.equ	SD_XMIT_STATE, 0xE8
.equ	SDI1, 0xE9
.equ	SDI2, 0xEA
.equ	SDI3, 0xEB
.equ	SDI4, 0xEC

.equ	RESET, 0
.equ	PORT1, 0xF6

.equ	NPS, 0x9e

.equ	LED_STATE, 0x40

.equ	NCMD, 0xa1
.equ	NSRCL, 0xa2
.equ	NSRCH, 0xa3

.equ	SD_WAITING, 0x24

.org 0x4700
; This gets called from the ROM.
; ---------------------------------------------------------------------------
; This gets called from an interrupt context, from within ROM.  We want to
; manipulate the stack so that when we return from interrupt, code execution
; will continue at an address immediately following this code section.
reset_vector:
	anl	0xDC, #0xFE
	pop	ACC
	pop	ACC
	mov	A, #0x10
	push	ACC
	mov	A, #0x47
	push	ACC
	reti			; Return from interrupt, ending up at 0x7b0c


;---------------------------------------------------------------------------
.org 0x4710
start:

	mov	IEN, #0		; Disable interrupts
	mov	SP, #0x80	; Reset stack pointer
	;mov	0xb4, #0x6b
	ljmp	dump_rom



dump_rom:
	mov	0xef, #0x00
	lcall	pause
	;mov	DPTR, #0x4500
	mov	DPTR, #0
	nop
	nop
	nop

dump_rom_next_byte:
	clr	C
	clr	A
	movx	A, @DPTR
	;movc	A, @A+DPTR
	mov	R4, #8

bit_shift_top:
	mov	R5, #0x08
	jnb	ACC.7, bit_is_zero
	mov	R5, #0x0a
bit_is_zero:
	mov	0xef, R5
	lcall	pause

	mov	0xef, #0x00
	lcall	pause
	rl	A
	djnz	R4, bit_shift_top

	lcall	pause
	ljmp	dump_rom_next_byte

long_pause:
pause:
	mov	R6, #0xff
	mov	R7, #0x30
	mov	R3, #0x01
pause_loop:
	djnz	R6, pause_loop
	djnz	R7, pause_loop
	djnz	R3, pause_loop
	ret
;
;long_pause:
;	mov	R6, #0xff
;	mov	R7, #0x50
;	mov	R3, #0x01
;long_pause_loop:
;	djnz	R6, long_pause_loop
;	djnz	R7, long_pause_loop
;	djnz	R3, long_pause_loop
;	ret

.org 0x4780
	.db	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
	.db	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f

	.db	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17
	.db	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f

	.db	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27
	.db	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f

	.db	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37
	.db	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f

	.db	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47
	.db	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f

	.db	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57
	.db	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f

	.db	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67
	.db	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f

	.db	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77
	.db	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f
